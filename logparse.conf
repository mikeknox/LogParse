# Describe config file for log parse / summary engine
# Input fields from syslog:
# Date, time, server, application, facility, ID, message
#
# Config line
# /server regex/, /app regex/, /facility regex/, /msg regex/, $ACTIONS
# Summaries are required at various levels, from total instances to total sizes to server summaries.
# ACTIONS:
# COUNT - Just list the total number of matches
# SUM[x] - Report the sum of field x of all matches
# SUM[x], /regex/ - Apply regex to msg field of matches and report the sum of field x from that regex 
# SUM[x], /regex/, {y,z} - Apply regex to msg field of matches and report the sum of field x from that regex for fields y & z
# COUNT[x], /regex/, {y,z} - Apply regex to msg field of matches and report the count of field x from that regex for matching fields y & z
#
# Each entry can test or regex, if text interpret as regex /^string$/
# Sample mail session ...
# Questions to be answered: 
#  1./ from:to
#  2./ from:size
#  3./ to:size
#  4./ relay? delay? status?
# rule{mailfrom{id - key} = from; rule{mailto}{id-key:to} ; report rule to combine rules mailfrom & mailto
#
# RSH
#
#(.*) in.rshd mail.info connect COUNT /(.*)\s+(.*)\s+(.*)\s+(.*)\s+in\.rshd(.*) connect from (.*)/ {6,4} REPORT "RSH Connections" "{x} from {2} to {1}"
RULE {
#	HOST (.*)
	APP in.rshd
	FACILITY mail.info
	MSG connect
	CMD {
		REGEX /(.*)\s+(.*)\s+(.*)\s+(.*)\s+in\.rshd(.*) connect from (.*)/
		MATCH {6,4}
		COUNT
	}
	REPORT {
		TITLE "RSH Connections"
		LINE "{x} from {2} to {1}"	
	#	SORTBY {x}
	}
}
#
# POP3
#
RULE poplogout {
	APP ipop3d
	FACILITY mail.(debug|info)
	MSGREGEX Logout
	CMD {
		REGEX /Logout user=(.*) host=(.*) /
		MATCH {2,1}
		COUNT
	}
	REPORT {
		TITLE "POP3 Logouts"
		LINE "{x} logout(s) from {2} by {1}"
	}
}
RULE {
	APP ipop3d
	FACILITY mail.info
	MSGREGEX Login
	CMD {
		REGEX /Login user=(.*) host=(.*) /
		MATCH {1,2}
		COUNT
	}
	REPORT {
		TITLE "POP3 Logins"
		LINE "{x} login(s) by {1} from {2}"
	}
}
RULE testpop {
	APP ipop3d
	#FACILITY (.*)
	#MSGREGEX (.*)
	CMD {
		REGEX /service init from (.*)/
		MATCH {1}
		COUNT
	}
	REPORT {
		TITLE "POP3 init"
		LINE "{x} from {1}"
	}
}
#
# IMAP
#
#core1 imap mail.info Login COUNT /Login user=(.*) host=(.*) \[(.*)\]/ {2,1} REPORT "IMAP Logins" "{x}: logins from {2} by {1}"
RULE {
	APP imap
	FACILITY mail.info
	MSGREGEX Login
	CMD {
		REGEX /Login user=(.*) host=(.*)/
		#\[(.*)\]/
		MATCH {2,1}
		COUNT
	}
	REPORT {
		TITLE "IMAP Logins"
		LINE "{x}: logins from {2} by {1}"
	}
}
RULE x {
	APP imap
	FACILITY mail.info
	MSGREGEX Logout
	CMD {
		REGEX /Logout user=(.*) host=(.*)/
		#\[(.*)\]/
		MATCH {2,1}
		COUNT
	}
	REPORT {
		TITLE "IMAP Logouts"
		LINE "{x}: logouts from {2} by {1}"
	}
}
RULE {
	APP imap
	FACILITY mail.debug
	MSG service
	CMD {
		REGEX /service init from (.*)/
		MATCH {1}
		COUNT
	}
	REPORT {
		TITLE "IMAP init"
		LINE "{x} from {1}"
	}
}
#
# LSF
#
#(.*) LSF_Elim (.*) (.*) COUNT REPORT "LSF Elim Reports" "{x} reports on all hosts"
RULE {
#	HOST (.*) 
	APP LSF_Elim
#	FACILITY (.*)
#	MSG (.*)
	CMD COUNT 
	REPORT {
		TITLE "LSF Elim Reports"
		LINE "{x} reports on all hosts"
	}
}
#atlas LSF_Elim (.*) (.*) COUNT REPORT "LSF Elim Reports" "{x} reports on atlas"
RULE {
	APP LSF_Elim
	#FACILITY (.*)
	#MSG (.*)
	CMD COUNT
	REPORT {
		TITLE "LSF Elim Reports"
		LINE "{x} reports on atlas"
	}
}
#
# Postfix
#
#(.*) postfix/qmgr (.*) (.*) SUM[3] /from=<(.*)\@(.*)>, size=(.*), nrcpt=(.*) \(/ REPORT "Mail received (size)" "{x} bytes received in total"
RULE {
	#HOST (.*)
	APP postfix/qmgr
	#FACILITY (.*)
	#MSG (.*)
	CMD {
		REGEX /from=<(.*)\@(.*)>, size=(.*), nrcpt=(.*) \(/
		SUM[3]
	}
	REPORT {
		TITLE "Mail received (size)"
		LINE "{x} bytes received in total"
	}
}
#(.*) postfix/qmgr (.*) (.*) SUM[3] /from=<(.*)\@(.*)>, size=(.*), nrcpt=(.*) \(/ {2} REPORT "Mail received Domain(size)" "{x} bytes received from domain {1}"
RULE {
	#HOST (.*)
	APP postfix/qmgr
	#FACILITY (.*)
	$MSG (.*)
	CMD {
		REGEX /from=<(.*)\@(.*)>, size=(.*), nrcpt=(.*) \(/
		MATCH {2}
		SUM[3]
	}
	REPORT {
		TOTAL "Mail received Domain(size)"
		LINE "{x} bytes received from domain {1}"
	}
}
#(.*) postfix\/qmgr (.*) (.*) SUM[2] /from=<(.*)>, size=(.*), nrcpt=(.*) \(/ {1} REPORT "Mail received (size)" "{x} bytes received from {1}"
RULE {
	#HOST (.*) 
	APP postfix\/qmgr
	#FACILITY (.*)
	#MSG (.*)
	CMD {
		SUM[2]
		REGEX /from=<(.*)>, size=(.*), nrcpt=(.*) \(/
		MATCH {1}
	}
	REPORT {
		TITLE "Mail received (size)"
		LINE "{x} bytes received from {1}"
	}
}
#core1 postfix\/(local|smtp) (.*) (.*) COUNT /to=<(.*)>, relay=(.*), delay=(.*), status=(.*) \(/ {1} REPORT "Mail sent to" "{x} emails sent to {1}"
RULE {
	HOST ahost
	APP postfix\/(local|smtp)
	#FACILITY (.*)
	#MSG (.*)
	CMD {
		COUNT
		REGEX /to=<(.*)>, relay=(.*), delay=(.*), status=(.*) \(/
		MATCH {1}
	}
	REPORT {
		TITLE "Mail sent to"
		LINE "{x} emails sent to {1}"
	}
}
#(.*) postfix\/smtpd mail.info ^connect COUNT /^connect from (.*)\[(.*)\]/ {1,2} REPORT "Email connections:" "{x} conections from {2} as {1}"
RULE {
	#HOST (.*)
	APP postfix\/smtpd
	FACILITY mail.info
	MSG ^connect
	CMD {
		COUNT
		REGEX / connect from (.*)\[(.*)\]/
		MATCH {1,2}
	}
	REPORT {
		TITLE "Email connections:"
		LINE "{x} conections from {2} as {1}"
	}
}
#core1 postfix/smtpd mail.info /^reject/ COUNT /^reject: RCPT from (.*): 554 <(.*)>: Sender address rejected: Access denied; from=<(.*)> to=<(.*)>/ {2,3} REPORT "Possible spam bounces" "{x} bounces for {2} from {1}"
RULE {
	APP postfix/smtpd
	FACILITY mail.info 
	MSG /^reject/ 
	CMD {
		COUNT 
		REGEX /^reject: RCPT from (.*): 554 <(.*)>: Sender address rejected: Access denied; from=<(.*)> to=<(.*)>/
		MATCH {2,3}
	}
	REPORT {
		TITLE "Possible spam bounces"
		LINE "{x} bounces for {2} from {1}"
	}
}
RULE {
	APP postfix/smtpd
	FACILITY mail.info
	MSG /(.*):  client=/
	CMD IGNORE
}
#
# ClearCase
#
RULE CC {
	APP ClearCase
	MSG cleartool
	CMD {
		REGEX /ClearCase: (.*): \"cleartool (.*)\": (.*)\./
		MATCH {1,2,3}
		COUNT
	}
	REPORT {
		TITLE "ClearCase actions"
		LINE "{x} x {2} by {1} with status {1}"
	}
}
RULE {
	APP ClearCase
	#MSG cleartool
	CMD {
		# USER: VOB: VIEW TAG: action: script: status
		REGEX /ClearCase: (.*): (.*): (.*): (.*): (.*)\./
		MATCH {1,3,5}
		COUNT
		#APPEND RULE CC
	}
	REPORT {
		TITLE "ClearCase stuff"
		LINE "{x} {2} {3} by {1}"
	}
}
RULE {
	APP ClearCase
#	MSG cleartool
	CMD {
		# USER: VOB: TRIGGER: action: file
		REGEX /ClearCase: (\w+):(\w+):(\w+):(\w+):(\w+)/
		MATCH {1,3,5}
		COUNT
		#APPEND RULE CC
	}
	REPORT {
		TITLE "ClearCase Trigger"
		LINE "{x} {2} by {3} for {1}"
	}
}
#
# Sendmail
#
#(.*) sendmail mail.info 
#
# IGNORE
#
#RULE {
#	APP dhcpd
#	FACILITY daemon.info
#	MSG DHCP
#	CMD IGNORE
#}
#RULE {
#	APP postfix\/smtpd
#	FACILITY mail.info
#	MSG disconnect
#	CMD {
#		IGNORE
#		REGEX / disconnect from/
#	}
#}
#RULE {
#	APP postfix\/pickup
	#FACILITY (.*)
#	MSG /^(.*): uid=(.*) from=<(.*)>$/
#	CMD IGNORE
#}
#RULE {
#	APP postfix\/cleanup
#	FACILITY mail.info
#	MSG /^(.*): message-id=<(.*)>$/
#	CMD IGNORE
#}
#RULE {
	#HOST (.*)
#	APP xntpd
#	#FACILITY (.*)
#	MSG time
#	CMD {
#		IGNORE
#		REGEX / time reset/
#	}
#}

RULE MTAcheck {
	APP sendmail
	#FACILITY mail.info
	MSG /NOQUEUE: (.*) did not issue MAIL/EXPN/VRFY/ETRN during connection to/
	CMD {
		REGEX / NOQUEUE: (.*) did/
		MATCH {svr,1}
		COUNT
	}
	REPORT {
		TITLE "Sendmail checks by BB"
		LINE "{x} to {2} by {1}"
	}
}

RULE {
	APP sendmail
	FACILITY mail.info
	MSG /(.*): (.*) \[(.*)\] did not issue MAIL/EXPN/VRFY/ETRN during connection to/
	CMD {
		REGEX / (.*): (.*) \[(.*)\] did/
		MATCH {svr,2}
		COUNT
		APPEND MTAcheck
	}
	REPORT {
		TITLE "Sendmail checks by BB"
		LINE "{x} to {2} by {1}"
	}
}

RULE {
	APP sshd
	MSG /Bad protocol version identification 'Big-Brother-Monitor-1.9c/
	CMD {
		REGEX /Bad protocol version identification/
		MATCH {svr}
		COUNT
	}
	REPORT {
		TITLE "SSH checks by BB"
		LINE "{x} to {1}"
	}
}
RULE {
	APP postfix/smtpd
	FACILITY mail.info
	MSG /(.*): client=(.*)\[*.*\]/
	CMD IGNORE
}
RULE {
	APP postfix/smtpd
	FACILITY mail.info
	MSG /reject: (.*): 554 /
	CMD {
		REGEX /reject: RCPT from (.*): 554 \<(.*)\>: Sender address rejected: Access denied; from=\<(.*)\> to=\<(.*)\>/
		MATCH {3,4}
		COUNT
	}
	REPORT {
		TITLE "Sender denied"
		LINE "{x} to {1} from {2}"
	}
}

RULE {
 APP sendmail
 HOST !somehost
 MSG /^(.*): (to|from)/
 CMD IGNORE
}
#
###############################################################################
#
RULE {
  APP automount
  CMD {
     REGEX /lookup\(yp\): lookup for (.*) failed: No such key in map/
     MATCH {svr,1}
     COUNT
  }
  REPORT {
     TITLE "Automount lookup failed"
     LINE "{x} for {1} on {2}"
  }
}
#
RULE {
 APP automount
 CMD {
  REGEX /expired (.*)/
  MATCH {svr,1}
  COUNT
 }
 REPORT {
  TITLE "Automount expired"
  LINE "{x} expires for {1} on {2}"
 }
}
#
RULE {
 APP automount
 CMD {
  REGEX /mount\(nfs\): nfs: mount failure (.*) on (.*)/
  MATCH {svr,1,2}
  COUNT
 }
 REPORT {
  TITLE "Automount failure "
  LINE "{x} automount failures for {1} to {2} on {3}"
 }
}
#
RULE {
 # This is a follow on message from the previous automount - mount failure
 APP automount
 REGEX /\>\> (.*) failed, reason given by server: No such file or directory/
 IGNORE
}
#
#######################
#
RULE {
 APP pam_rhosts_auth
 CMD {
  REGEX /allowed to (.*) as (.*)/
  MATCH {1,2,svr}
  COUNT
 }
 REPORT {
  TITLE "RHosts authtentication"
  LINE "{x} rhosts connections as {2} for {3} to {1}"
 }
}
#
RULE {
 APP pam_rhosts_auth
 CMD {
  REGEX /denied to (.*) as (.*): access not allowed/
  MATCH {1,2,svr}
  COUNT
 }
 REPORT {
  TITLE "RHosts authtentication denial"
  LINE "{x} attempted rhosts connections as {2} for {3} to {1} denied"
 }
}
#
#######################
#
RULE {
 APP nmbd
 REGEX /nmbd\/nmbd_(.*).c:/
 IGNORE
}
#
RULE {
 APP nmbd
 REGEX /\*\*\*\*\*/
 IGNORE
}
#
RULE {
 APP nmbd
 REGEX /:\s+$/
 IGNORE
}
#
RULE {
 APP nmbd
 CMD {
  REGEX /process_local_master_announce: Server (.*) at IP (.*) is announcing itself as a local master browser for workgroup (.*) and we think we are master. Forcing election/
  MATCH {1,3,svr}
  COUNT
 }
 REPORT {
  TITLE "Browse Master Elections"
  LINE "{x} elections foreced from {1} for workgroup {2} because of {3}"
 }
} 
#
RULE {
 APP nmbd
 CMD {
  REGEX /Samba name server (.*) has stopped being a local master browser for workgroup (.*) on subnet (.*)/
  MATCH {1,2,3,svr}
  COUNT
 }
 REPORT {
  TITLE "Server has stopped being Browse Master"
  LINE "{x} times {4} on {1} has stopped being browse master for {2}/{3}"
 }
}
#
RULE {
 APP nmbd
 CMD {
  REGEX /Samba name server (.*) is now a local master browser for workgroup (.*) on subnet (.*)/
  MATCH {1,2,3,svr}
  COUNT
 }
 REPORT {
  TITLE "Server is now Browse Master"
  LINE "{x} times {4} on {1} has started being browse master for {2}/{3}"
 }
}
#
#######################
#
RULE {
 APP sendmail
 CMD {
   REGEX /(.*): from=(.*), size=(.*), class=(.*), pri=(.*), nrcpts=(.*), msgid=(.*), relay=(.*)/
   MATCH {svr,2,8}
   COUNT
   APPEND RULE sendmail_from
 }
 REPORT {
  TITLE "Email sent from:"
  LINE "{x} emails sent by {1} from {2} via {3}"
 }
}
#
RULE sendmail_from {
 APP sendmail
 CMD {
   #REGEX /(.*): from=(.*), size=(.*), class=(.*), pri=(.*), nrcpts=(.*), msgid=(.*), relay=(.*)/
   REGEX /(.*): from=(.*), size=(.*), class=(.*), nrcpts=(.*), msgid=(.*), relay=(.*)/
   MATCH {svr,2,7}
   COUNT
 }
 REPORT {
  TITLE "Email sent from"
  LINE "{x} emails sent by {1} from {2} via {3}"
 }
}
#
RULE sendmail_to_2 {
 APP sendmail
 CMD {
   REGEX /(.*): to=(.*), ctladdr=(.*) \(.*\), delay=.*, xdelay=.*, mailer=(.*), pri=(.*), relay=(.*) \[(.*)\], dsn=(.*), stat=(.*) \((.*) Message accepted for delivery\)/
   MATCH {svr,2,6}
   COUNT
   APPEND sendmail_to
 }
 #REPORT {
   #TITLE "Email sent to"
   #LINE "{x} emails sent to {2} via {3}"
 #}
}
#
RULE sendmail_to {
 APP sendmail
 HOST somehost
 CMD {
   REGEX /(.*): to=(.*), delay=(.*), xdelay=(.*), mailer=(.*), relay=(.*) \[(.*)\], stat=Sent \(2.0.0 (.*) Message accepted for delivery\)/
   MATCH {svr,2,6}
   COUNT
 }
 REPORT {
   TITLE "Email sent to"
   LINE "{x} emails sent to {2} via {1}"
 }
}
#
#######################
#
